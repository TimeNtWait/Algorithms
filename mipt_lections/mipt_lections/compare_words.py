# Определение редакционного расстояния между строками (Расстояние Левенштейна)
# Требуется найти минимальное кол-во операций над символами строки, необходимое
# для превращения одной строки в другую.
# Допускаются следующие действия над символами строки: замена, удаление, добавление.
#
# Например редакционное расстояние между словами "колокол" и "молоко"
# составляет 2. Т.к. минимальные действия:
#  - 1. заменить первую букву "к" на "м",
#  - 2.удалить последнюю "л"

# Функция сравнения работает по следующему алгоритму:
# 1.Формируется матрица подсчета редакционного расстояния. Матрица формируется
# в соответсвтии с размером сравниваемых слов, т.е. размер матрицы N+1 на M+1,
# где N - размер первого слова, а M - размер второго. первая строка и первый
# столбец матрицы заполняются от 0 и далее инкрементально увеличивающимся
# значением на +1, т.е. 0,1,2,3,4...
# Для слов "колокол", "молоко" матрица будет иметь изначальное наполнение
#       М  о  л  о  к  о
#   [0, 1, 2, 3, 4, 5, 6]
# К [1, 0, 0, 0, 0, 0, 0]
# о [2, 0, 0, 0, 0, 0, 0]
# л [3, 0, 0, 0, 0, 0, 0]
# о [4, 0, 0, 0, 0, 0, 0]
# к [5, 0, 0, 0, 0, 0, 0]
# о [6, 0, 0, 0, 0, 0, 0]
# л [7, 0, 0, 0, 0, 0, 0]
# 2. Запускается посимвольный цикл по двум словам (вложенный массив)
# Производится сравнение каждого символа с каждым. Прохождение цикла
# осущесвтляется с использование индексов i, j в соответсвтии со словами
# 3.1 Если символы равны то в матрица в соответсвтующей позиции пересечения
# индексов (i,j) указывается предыдущее диогональное значение ([i - 1][j - 1])
# 3.2. Если символы различаются тогда в ячейку (i,j) записывается минимальное
# значение между предыдущими значениями по горизонтали/вертикали/диагонали:
# min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1])
# В итоге формируется матрица:
#       м  о  л  о  к  о
#   [0, 1, 2, 3, 4, 5, 6]
# к [1, 1, 2, 3, 4, 4, 5]
# о [2, 2, 1, 2, 3, 4, 4]
# л [3, 3, 2, 1, 2, 3, 4]
# о [4, 4, 3, 2, 1, 2, 3]
# к [5, 5, 4, 3, 2, 1, 2]
# о [6, 6, 5, 4, 3, 2, 1]
# л [7, 7, 6, 5, 4, 3, 2]
#
# Последнее значнеие в матрице равняется минимальному кол-ву редакционных
# правок, необходимых для перевода одного слова к другому
def compare_words3(w1: str, w2: str) -> int:
    f = [[(j + i if j == 0 or i == 0 else 0) for j in range(len(w2) + 1)] for i in range(len(w1) + 1)]
    for i in range(1, len(w1) + 1):
        for j in range(1, len(w2) + 1):
            if w1[i - 1] == w2[j - 1]:
                f[i][j] = f[i - 1][j - 1]
            else:
                f[i][j] = 1 + min(f[i][j - 1], f[i - 1][j], f[i - 1][j - 1])
    # Вывод матричного представления рассчетов динамического программирования
    # print(*f, sep="\n")
    return f[len(w1)][len(w2)]


tests = [
    ["колокол", "молоко", 2],
    ["молоко", "мо", 4],
    ["sdfsdfvмdоf", "мо", 9],
    ["моcло", "моло", 1],
    ["моcло", "моddлfо", 3],
    ["моcccло", "моddлfо", 4],
    ["маал", "малал", 1],
    ["молоко", "молwоко", 1],
]
for i, test in enumerate(tests):
    w1 = test[0]
    w2 = test[1]
    true_answer = test[2]
    min_change = compare_words3(w1, w2)
    print(min_change)
    print(f"test #{i + 1}, w1: '{w1}', w2: '{w2}'", "Ok" if true_answer == min_change else "Fail")

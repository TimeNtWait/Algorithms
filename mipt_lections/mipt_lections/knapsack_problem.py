"""Задача по укладке рюкзака (Knapsack problem)
Задача: уложить как можно большее число ценных предметов в рюкзак при условии,
что вместимость рюкзака ограничена

Два решения:
- рекурсия
- динамическое программирование
"""


def knapsack_dynamic_programming(
        items: list[int],
        prices: list[float],
        max_mass: int,
        cost: int = 0,
        maxcost: int = 0) -> int:
    """Задача укладки рюкзака решается через динамическое программирвоание

    Суть алгоритма:
    1. Входные данные:
        - Список N предметов с указанием весов и ценностей,
        - K - значение максимально допустимого веса рюкзака
        Например:
            Предмет   1  2  3  4
            Вес      [3, 1, 2, 4]
            Ценность [2, 5, 6, 7]
            K = 5
    2. Формируется матрица "(K+1)*(N+1)", где "K" - максимально допустимый вес
      рюкзака и "N" - кол-во предметов. Матрица учитывает кол-во предметов "+1" и
      допустимый вес "+1" для учета нулевого состояния, когда в рюкзак не поместили
      ни одного предмета.
    3. Производится заполнение  матрицы по следующему принципу:
      Выбирается максимальная ценность между вариантом брать предмет или не брать
      другими словами предыдущим состоянием
      Строка предмета заполняется:
      - Для позиций "k" когда "k" не достигло веса предмета, строка
      заполняется значениями с предыдущей строки, т.е. вначале это будут нули
      - далее, когда позиция "k" в строке достигла веса предмета происходит
      расчет по формуле макс между (предыдущее значние в строке "k-1") и
      (ценность предмета + ценность которая была без веса предмета).
      Ценность без веса предмета определяется по рассчитаным значениям в матрице.
      Другими словами сравнимаем ценность по одинаковому весу, для этого смотрим
      ценность рюкзака на момент ("k") - вес текущего предмета и прибавляем к
      этому стоимость самого предмета и полученную стоимость сравниваем с
      предудущей ценой рюкзака, испоьлзуем большее значение/
    например для K = 5 N = 4:
    N\K 0 1 2 3  4  5
    0   0 0 0 0  0  0
    1   0 0 0 2  2  2
    2   0 5 5 5  7  7
    3   0 5 6 11 11 11
    4   0 5 6 11 11 12


    :param items: доступные предметы, которые еще не были положены в рюкзак
    :param prices: ценность доступных предметов
    :param max_mass: доступная масса, при первом запуске ф-ции указывается
    максимальная грузоподъемность рюкзака, далее допустимая масса уменьшается
    на значение тех предметов которые уже в рюкзаке
    :param cost: текущая ценность предметов которые уже в рюкзаке
    :param maxcost: максимально достигнутая ценность
    :return максимально достигнутая ценность
    """
    f = [[0] * (max_mass + 1) for _ in range(len(items) + 1)]
    for i in range(1, len(items) + 1):
        for j in range(1, max_mass + 1):
            width = items[i - 1]
            price = prices[i - 1]
            if j < width:
                f[i][j] = f[i - 1][j]
            else:
                f[i][j] = max(f[i][j - 1], price + f[i - 1][j - width])
    print(*f, sep="\n")
    return max(list(map(max,f)))


def knapsack_recursion(items: list[int], prices: list[float], max_mass: int, cost: int = 0, maxcost: int = 0) -> int:
    """Рекурсивное решение задачи по укладке рюкзака
    На каждом уровни рекурсии:
        1. в рюкзак добавляется новая позиция
        2. доступная масса рюкзака уменьшается на вес добавленого предмета
        3. ценность предметов увеличивается на ценность добавленого предмета
    Таким образом выполняется перебор всех возможных комбинаций предметов
    Возвращается наибольшая достигнутая ценность при допустимой массе

    :param items: доступные предметы, которые еще не были положены в рюкзак
    :param prices: ценность доступных предметов
    :param max_mass: доступная масса, при первом запуске ф-ции указывается
    максимальная грузоподъемность рюкзака, далее допустимая масса уменьшается
    на значение тех предметов которые уже в рюкзаке
    :param cost: текущая ценность предметов которые уже в рюкзаке
    :param maxcost: максимально достигнутая ценность
    :return максимально достигнутая ценность
    """
    for i in range(len(items)):
        if max_mass - items[i] >= 0:
            maxcost = knapsack_recursion(items[0:i] + items[i + 1:],
                                         prices[0:i] + prices[i + 1:],
                                         max_mass - items[i],
                                         cost + prices[i], maxcost)
    if cost > maxcost:
        maxcost = cost
    # Выход если допустимый вес исчерпан или закончились предметы
    if len(items) == 0 or max_mass == 0:
        return maxcost
    return maxcost


if __name__ == "__main__":
    items = [3, 5, 6, 1, 2, 1, 3, 4]
    prices = [4, 3, 2, 1, 5, 6, 3, 2]
    max_mass = 5
    print(f"Решение задачи укладки рюкзака через рекурсию: ")
    maxcost = knapsack_recursion(items, prices, max_mass)
    print(maxcost)


    prices = [1, 2, 1, 3, 1]
    items = [1, 1, 4, 3, 2]
    max_mass = 5

    prices = [2, 5, 6, 7]
    items = [3, 1, 2, 4]
    max_mass = 5


    print(f"\nРешение задачи укладки рюкзака через динамическое программирвоание: ")
    maxcost = knapsack_dynamic_programming(items, prices, max_mass)
    print(maxcost)
